# Linux-awk
{: id="20210409015630-tj35e48" updated="20210409020643"}

# awk 打印从某一列到最后一列的内容
{: id="20210409015628-73sqnam" updated="20210409015703"}

awk命令
{: id="20210409015719-j2tnxaj"}

```shell
history|awk -F " " '{for (i=2;i<=NF;i++)printf("%s ", $i);print ""}'
```
{: id="20210409015736-6xpacvb"}

详解：
{: id="20210409015719-bbivvue"}

history：Linux命令
{: id="20210409015719-3qws0j7"}

awk -F “ ”  以空格为分隔符
{: id="20210409015719-czcyekm"}

for (i=2;i<=NF;i++) printf("%s ",$i)  从第二列开始到最后，注意%s 后面有空格。
{: id="20210409015719-fkr3qrx"}

print “” 打印组合
{: id="20210409015719-gnd8bdl"}

{: id="20210409015823-maq13x8"}

# awk, 打印最后一列
{: id="20210409015822-so6zgb0" updated="20210409015831"}

## 常用
{: id="20210409021121-89rvja6" updated="20210409021125"}

```shell
$ll|awk -F " " '{print $NF}'
```
{: id="20210409021127-xd8zm3i" updated="20210409021141"}

{: id="20210409021127-icn09ni"}

## 基本
{: id="20210409020147-5gmdfno" updated="20210409020153"}

注意, 大括号用 **单引号** 括起来
{: id="20210409015838-kort9es" updated="20210409020457"}

```shell
$ awk '{print $NF}' a.txt 

$ ll|awk -F " " '{print $NF}'
```
{: id="20210409015833-65ac44o" updated="20210409020610"}

## others
{: id="20210409015833-megm0bs" updated="20210409020159"}

统计分析中经常用的awk命令，其中用的最多的还是切分
{: id="20210409020201-tj7fsry"}

```
cat  test | awk -F',' '{print $1,$2}
```
{: id="20210409020201-oz1uq19" updated="20210409020212"}

能够很好的将记录按照需要切分开，
{: id="20210409020209-i7ro067" updated="20210409020209"}

但是如何获取最后一列呢？
{: id="20210409020201-tp63s9q"}

可以使用`awk -F',' '{print $NF}'`来获取
{: id="20210409020201-3dt8ims" updated="20210409020223"}

求和
{: id="20210409020201-jfk3usn"}

-F，用，号分隔，求第3行的和
{: id="20210409020201-03isxip"}

```
awk -F',' '{sum += $NF};END{print sum}'
```
{: id="20210409020201-kdwy3lj" updated="20210409020235"}

{: id="20210409020201-wq00ubr"}

{: id="20210409015948-ernd5ep"}

# AWK – 打印最后一列以及空值
{: id="20210409015949-x9hio0g" updated="20210409020021"}

如果我们不知道最后一个列号,我们可以使用$NF打印文件中每行的最后一列.但是我面临的困难是最后一列有空值.
{: id="20210409015949-hve5spu"}

例如,解析谁命令
{: id="20210409015949-34ryqip"}

```
$who
root     tty1         2018-01-25 09:36
root     pts/0        2018-05-30 07:39 (192.168.1.134)
root     pts/1        2018-05-28 23:12 (192.168.1.134)
root     pts/2        2018-06-01 10:01 (192.168.1.188)
```
{: id="20210409015949-9e2xwgv"}

获得结果：
{: id="20210409015949-2mq6pdp"}

```
$who | awk '{print $NF}'
09:36
(192.168.1.134)
(192.168.1.134)
(192.168.1.188)
```
{: id="20210409015949-1piovex"}

预期结果
{: id="20210409015949-7v9ee98"}

```

(192.168.1.134)
(192.168.1.134)
(192.168.1.188)
复制代码
```
{: id="20210409015949-4mwa335"}

让我知道在单行中获得预期结果的可能性.
{: id="20210409015949-ogyb2sb"}

编辑1：以上场景只是一个例子.我不喜欢更改分隔符来实现结果.
{: id="20210409015949-j44xr1d"}

编辑2：字段数少于最大值的行没有(空行输出)
{: id="20210409015949-o0f2frz"}

最佳答案
{: id="20210409015949-sjcd0wo"}

要仅输出具有最大列数的行的最后一列,您可以执行以下操作：
{: id="20210409015949-g45wuym"}

```
who | awk '
  NF > max  {max = NF; output = ""}
  NF == max {output = output $NF ORS}
  END       {printf "%s", output}'
```
{: id="20210409015949-aq8hr6l"}

为每行输入输出一行,但对于没有最大列数的行输出空白：
{: id="20210409015949-4dib16p"}

```
who | awk '
  NF > max {max = NF}
  {n[NR] = NF}
  NF == max {last[NR] = $NF}
  END {for (i = 1; i <= NR; i++) print n[i] == max ? last[i] : ""}'
```
{: id="20210409015949-wtx6yfi"}

{: id="20210409015949-p9tgfbc"}


{: id="20210409015628-1uqki7p" type="doc"}
