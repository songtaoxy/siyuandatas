## 简介
{: id="20210411202848-w0mtyln"}

> 启动时加载的 JavaAgent 是 JDK1.5 之后引入的新特性，此特性为用户提供了在 JVM 将字节码文件读入内存之后，JVM 使用对应的字节流在 Java 堆中生成一个 Class 对象之前，用户可以对其字节码进行修改的能力，从而 JVM 也将会使用用户修改过之后的字节码进行 Class 对象的创建。
> {: id="20210411202848-u4zx2ur"}
{: id="20210411202848-9ndm2ok"}

## 是什么
{: id="20210411202848-ahrpzeg"}

介绍javaagent之前也要介绍另一个概念JVMTI。 JVMTI是JDK提供的一套用于开发JVM监控, 问题定位与性能调优工具的通用编程接口（API）。 通过JVM TI，我们可以开发各式各样的JVMTI Agent。这个Agent的表现形式是一个以C/C++语言编写的动态共享库。 javaagent可以帮助我们快速使用JVMTI的功能，又不需要重写编写C/C++的底层库。
{: id="20210411202848-d68m0xz"}

javaagent是依赖Java底层提供的一个叫instrument的JVMTI Agent。这个agent又叫JPLISAgent(Java Programming Language Instrumentation Services Agent)
{: id="20210411202848-kg646b4"}

> 简单来说, jvm提供了一个(底层性的)接口, 程序员调用该接口, 可以改变jvm运行方式.比如可以修改程序员本来已经编译好的class文件. 按理说, 程序员通过javac编译xx.java文件后得到xx.class, 该class文件是不能修改的, 要不然在jvm加载过程中通不过校验. 
> {: id="20210411203857-kn45xmp" updated="20210411204222"}
{: id="20210411203855-lmc0wie" updated="20210411203857"}

简单来说，javaagent是一个JVM的“插件”。 在Java运行命令中 javaagent是一个参数，用来指定agent. 如何指定该参数, see ((20210411201036-nk3yx38 "{{.text}}"))
{: id="20210411202848-kg032e7" updated="20210411203046"}

## 能做什么
{: id="20210411202848-ckbhr8t"}

* {: id="20210411202848-9lfpm7v"}可以在加载class文件之前进行拦截并把字节码做修改。
  {: id="20210411202848-k8g50v1"}
* {: id="20210411202848-9tz40rk"}可以在运行期对已加载类的字节码做变更，但是这种情况下会有很多的限制。
  {: id="20210411202848-aa5p7j6"}
* {: id="20210411202848-jo9n266"}还有其他一些小众的功能
  {: id="20210411202848-2ptei7i"}

  * {: id="20210411202848-tt6vc8i"}获取所有已经加载过的类
    {: id="20210411202848-vlpyduk"}
  * {: id="20210411202848-4bzojz2"}获取所有已经初始化过的类（执行过 clinit 方法，是上面的一个子集）
    {: id="20210411202848-bidubek"}
  * {: id="20210411202848-57timfy"}获取某个对象的大小
    {: id="20210411202848-qu0ap6z"}
  * {: id="20210411202848-5az06rz"}将某个jar加入到bootstrap classpath里作为高优先级被bootstrapClassloader 加载
    {: id="20210411202848-hws8zyh"}
  * {: id="20210411202848-4b04zon"}将某个jar加入到classpath里供AppClassloard去加载
    {: id="20210411202848-69s9qle"}
  * {: id="20210411202848-fh19obq"}设置某些native方法的前缀，主要在查找native方法的时候做规则匹配
    {: id="20210411202848-11eycn0"}
  {: id="20210411202848-zrsoe59"}
{: id="20210411202848-9nf4qs5"}

总的来说可以让JVM按照我们的预期逻辑去执行。
{: id="20210411202848-tfmvtwm"}

最主要的也是使用最广的功能就是对字节码的修改。通过对字节码的修改我们就可以实现对Java底层源码的重写，也正好可以满足我之前的需求。 我们还可以做：
{: id="20210411202848-u6rut6u"}

* {: id="20210411202848-lhgaepf"}完全非侵入式的进行代码埋点，进行系统监控
  {: id="20210411202848-lpad2jr"}
* {: id="20210411202848-b4jnjwy"}修改Java底层源码，进行JVM自定义
  {: id="20210411202848-anjhcnn"}
{: id="20210411202848-01wg8hu"}

{: id="20210411202848-4cyokbs"}


{: id="20210411202846-za1kt3b" type="doc"}
